"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = upgradeDependencies;

var _util = _interopRequireDefault(require("util"));

var _path = _interopRequireDefault(require("path"));

var _fs = require("fs");

var _boxen = _interopRequireDefault(require("boxen"));

var _rimraf = _interopRequireDefault(require("rimraf"));

var _semver = _interopRequireDefault(require("semver"));

var _resolveFrom = _interopRequireDefault(require("resolve-from"));

var _lodash = require("lodash");

var _readLocalManifest = _interopRequireDefault(require("@sanity/util/lib/readLocalManifest"));

var _findSanityModuleVersions = _interopRequireDefault(require("../../actions/versions/findSanityModuleVersions"));

var _printVersionResult = require("../versions/printVersionResult");

var _debug = _interopRequireDefault(require("../../debug"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const rimraf = _util.default.promisify(_rimraf.default);

async function upgradeDependencies(args, context) {
  const {
    output,
    workDir,
    yarn,
    chalk
  } = context;
  const {
    extOptions
  } = args;
  const {
    range,
    tag
  } = extOptions;
  const saveExact = extOptions['save-exact'];
  const targetRange = tag || range;

  if (range && tag) {
    throw new Error('Both --tag and --range specified, can only use one');
  }

  if (range && !_semver.default.validRange(range)) {
    throw new Error(`Invalid semver range "${range}"`);
  } // Find which modules needs update according to the target range


  const versions = await (0, _findSanityModuleVersions.default)(context, {
    target: targetRange,
    includeCli: false
  });
  const needsUpdate = versions.filter(mod => mod.needsUpdate);
  (0, _debug.default)('In need of update: %s', needsUpdate.map(mod => mod.name).join(', '));
  const semverBreakingUpgrades = versions.filter(hasSemverBreakingUpgrade);
  const baseMajorUpgrade = semverBreakingUpgrades.find(mod => mod.name === '@sanity/base');
  const majorUpgrades = semverBreakingUpgrades.filter(mod => mod.name !== '@sanity/base');
  schedulePrintMajorUpgrades({
    baseMajorUpgrade,
    majorUpgrades
  }, context); // If all modules are up-to-date, say so and exit

  if (needsUpdate.length === 0) {
    context.output.print(`${chalk.green('✔')} All Sanity modules are at latest compatible versions`);
    return;
  } // Ignore modules that are pinned, but give some indication that this has happened


  const pinned = needsUpdate.filter(mod => mod.isPinned);
  const nonPinned = needsUpdate.filter(mod => !mod.isPinned);
  const pinnedNames = pinned.map(mod => mod.name).join(`\n - `);

  if (nonPinned.length === 0) {
    context.output.warn(`${chalk.yellow('⚠')} All modules are pinned to specific versions, not upgrading:\n - ${pinnedNames}`);
    return;
  }

  if (pinned.length > 0) {
    context.output.warn(`${chalk.yellow('⚠')} The follow modules are pinned to specific versions, not upgrading:\n - ${pinnedNames}`);
  } // Replace versions in `package.json`


  const versionPrefix = saveExact || targetRange ? '' : '^';
  const oldManifest = await (0, _readLocalManifest.default)(workDir);
  const newManifest = nonPinned.reduce((target, mod) => {
    const savedVersion = targetRange && !saveExact ? targetRange : `${versionPrefix}${mod.latestInRange}`;

    if (oldManifest.dependencies && oldManifest.dependencies[mod.name]) {
      target.dependencies[mod.name] = typeof mod.latestInRange === 'undefined' ? // Keep as-is if we can't resolve within range/tag
      oldManifest.dependencies[mod.name] : // Store latest within range, or just the tag name if using that
      savedVersion;
    }

    if (oldManifest.devDependencies && oldManifest.devDependencies[mod.name]) {
      target.devDependencies[mod.name] = typeof mod.latestInRange === 'undefined' ? // Keep as-is if we can't resolve within range/tag
      oldManifest.dependencies[mod.name] : // Store latest within range, or just the tag name if using that
      savedVersion;
    }

    return target;
  }, oldManifest); // Write new `package.json`

  const manifestPath = _path.default.join(context.workDir, 'package.json');

  await writeJson(manifestPath, newManifest, {
    spaces: 2
  }); // Yarn fails to upgrade `react-ace` in some versions, see function for details

  await maybeDeleteReactAce(nonPinned, workDir); // Forcefully remove non-symlinked module paths to force upgrade

  await Promise.all(nonPinned.map(mod => deleteIfNotSymlink(_path.default.join(context.workDir, 'node_modules', mod.name.replace(/\//g, _path.default.sep))))); // Run `yarn install`

  const flags = extOptions.offline ? ['--offline'] : [];
  const cmd = ['install', '--check-files'].concat(flags);
  (0, _debug.default)('Running yarn %s', cmd.join(' '));
  await yarn(cmd, { ...output,
    rootDir: workDir
  });
  context.output.print('');
  context.output.print(`${chalk.green('✔')} Modules upgraded:`);
  const {
    versionLength,
    formatName
  } = (0, _printVersionResult.getFormatters)(nonPinned);
  nonPinned.forEach(mod => {
    const current = chalk.yellow((0, _lodash.padStart)(mod.installed || '<missing>', versionLength));
    const latest = chalk.green(mod.latestInRange);
    context.output.print(`${formatName(mod.name)} ${current} → ${latest}`);
  });
}

function writeJson(filePath, data) {
  return _fs.promises.writeFile(filePath, `${JSON.stringify(data, null, 2)}\n`);
}

async function deleteIfNotSymlink(modPath) {
  const stats = await _fs.promises.lstat(modPath).catch(_lodash.noop);

  if (!stats || stats.isSymbolicLink()) {
    return null;
  }

  return rimraf(modPath);
}

function hasSemverBreakingUpgrade(mod) {
  const current = mod.installed || tryGetMinVersion(mod.declared);
  return Boolean(current && !_semver.default.satisfies(mod.latest, `^${current}`) && _semver.default.gt(mod.latest, current));
}

function tryGetMinVersion(version) {
  try {
    return _semver.default.minVersion(version).toString();
  } catch (err) {
    return undefined;
  }
}

function getMajorUpgradeText(mods, chalk) {
  const modNames = mods.map(mod => `${mod.name} (v${_semver.default.major(mod.latest)})`).join('\n - ');
  return [mods.length === 1 ? `The following module has a new major version\n` : `The following modules have new major versions\n`, `released and will have to be manually upgraded:\n\n`, ` - ${modNames}\n\n`, chalk.yellow('⚠'), ` Note that major versions can contain backwards\n`, `  incompatible changes and should be handled with care.`].join('');
}

function getMajorStudioUpgradeText(mod, chalk) {
  const prev = _semver.default.major(mod.installed || _semver.default.minVersion(mod.declared).toString());

  const next = _semver.default.major(mod.latest);

  return ['There is now a new major version of Sanity Studio!', '', 'Read more about the new version and how to upgrade:', chalk.blueBright(`https://www.sanity.io/changelog/studio?from=v${prev}&to=v${next}`)].join('\n');
}

function schedulePrintMajorUpgrades({
  baseMajorUpgrade,
  majorUpgrades
}, {
  chalk,
  output
}) {
  if (majorUpgrades.length === 0 && !baseMajorUpgrade) {
    return;
  }

  process.on('beforeExit', () => {
    output.print(''); // Separate previous output with a newline

    if (baseMajorUpgrade) {
      output.warn((0, _boxen.default)(getMajorStudioUpgradeText(baseMajorUpgrade, chalk), {
        borderColor: 'green',
        padding: 1
      }));
      return;
    }

    output.warn((0, _boxen.default)(getMajorUpgradeText(majorUpgrades, chalk), {
      borderColor: 'yellow',
      padding: 1
    }));
  });
} // Workaround for https://github.com/securingsincity/react-ace/issues/1048
// Yarn fails to upgrade `react-ace` because `react-ace.min.js` is a _file_ in one version
// but a _folder_ in the next. If we're upgrading the `@sanity/code-input`, remove the
// `react-ace` dependency before installing


async function maybeDeleteReactAce(toUpgrade, workDir) {
  const codeInputUpdate = toUpgrade.find(mod => mod.name === '@sanity/code-input');

  if (!codeInputUpdate) {
    return;
  } // Assume it is an old version if we can't figure out which one is installed


  const installed = codeInputUpdate.installed ? codeInputUpdate.installed : '2.4.0';
  const upgradeTo = codeInputUpdate.latestInRange; // react-ace was upgraded in 2.24.1, so if we're going from <= 2.24.0 to => 2.24.1,
  // we should remove it.

  const shouldDelete = _semver.default.lte(installed, '2.24.0') && _semver.default.gte(upgradeTo, '2.24.1');

  if (!shouldDelete) {
    return;
  } // Try to find the path to it from `@sanity/code-input`, otherwise try the studio root `node_modules`


  const depRootPath = _path.default.join(workDir, 'node_modules');

  const closestReactAcePath = getModulePath('react-ace', _path.default.join(depRootPath, '@sanity', 'code-input')) || _path.default.join(depRootPath, 'react-ace');

  await rimraf(closestReactAcePath);
}

function getModulePath(modName, fromPath) {
  const manifestFile = `${modName.replace(/\//g, _path.default.sep)}/package.json`;

  const manifestPath = _resolveFrom.default.silent(fromPath, manifestFile);

  return manifestPath ? _path.default.dirname(manifestPath) : null;
}