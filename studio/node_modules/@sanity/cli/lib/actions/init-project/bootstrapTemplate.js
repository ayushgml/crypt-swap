"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var _chalk = _interopRequireDefault(require("chalk"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _lodash = require("lodash");

var _debug = _interopRequireDefault(require("../../debug"));

var _versionRanges = _interopRequireDefault(require("../../versionRanges"));

var _resolveLatestVersions = _interopRequireDefault(require("../../util/resolveLatestVersions"));

var _createManifest = require("./createManifest");

var _templates = _interopRequireDefault(require("./templates"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = async (opts, context) => {
  const {
    apiClient,
    cliRoot,
    output
  } = context;

  const templatesDir = _path.default.join(cliRoot, 'templates');

  const sourceDir = _path.default.join(templatesDir, opts.template);

  const {
    outputDir,
    projectId,
    template: templateName
  } = opts; // Check that we have a template info file (dependencies, plugins etc)

  const template = _templates.default[templateName];

  if (!template) {
    throw new Error(`Template "${templateName}" not defined`);
  } // Copy template files


  (0, _debug.default)('Copying files from template "%s" to "%s"', templateName, outputDir);
  let spinner = output.spinner('Bootstrapping files from template').start();
  await _fsExtra.default.copy(sourceDir, outputDir, {
    overwrite: false,
    errorOnExist: true
  });
  spinner.succeed(); // Merge global and template-specific plugins and dependencies

  const allModules = Object.assign({}, _versionRanges.default.core, template.dependencies || {});
  const modules = (0, _lodash.union)(Object.keys(_versionRanges.default.core), Object.keys(template.dependencies || {})); // Resolve latest versions of Sanity-dependencies

  spinner = output.spinner('Resolving latest module versions').start();
  const firstParty = modules.filter(isFirstParty);
  const thirdParty = (0, _lodash.difference)(modules, firstParty);
  const firstPartyVersions = await (0, _resolveLatestVersions.default)(firstParty, {
    asRange: true
  });
  const thirdPartyVersions = thirdParty.reduce((acc, dep) => {
    acc[dep] = allModules[dep];
    return acc;
  }, {});
  const dependencies = Object.assign({}, firstPartyVersions, thirdPartyVersions);
  spinner.succeed(); // Now create a package manifest (`package.json`) with the merged dependencies

  spinner = output.spinner('Creating default project files').start();
  const packageManifest = await (0, _createManifest.createPackageManifest)({ ...opts,
    dependencies
  }); // ...and a `sanity.json` manifest

  const baseSanityManifest = await (0, _createManifest.createSanityManifest)(opts, {
    serialize: false
  });
  const sanityManifest = template.generateSanityManifest ? template.generateSanityManifest(baseSanityManifest, opts) : baseSanityManifest; // Write non-template files to disc

  await Promise.all([writeFileIfNotExists('sanity.json', `${JSON.stringify(sanityManifest, null, 2)}\n`), writeFileIfNotExists('package.json', packageManifest), writeFileIfNotExists('.eslintrc', `${JSON.stringify({
    extends: '@sanity/eslint-config-studio'
  }, null, 2)}\n`)]); // Store template name metadata on project

  try {
    await apiClient({
      api: {
        projectId
      }
    }).request({
      method: 'PATCH',
      uri: `/projects/${projectId}`,
      body: {
        metadata: {
          initialTemplate: `cli-${templateName}`
        }
      }
    });
  } catch (err) {
    if (err.statusCode === 401) {
      output.warn(`\n${_chalk.default.yellow('⚠')} Unauthorized to update metadata for this project`);
    } else {
      output.warn(`\n${_chalk.default.red('⚠')} ${err.message}`);
    }
  } // Finish up by providing init process with template-specific info


  spinner.succeed();
  return template;

  async function writeFileIfNotExists(fileName, content) {
    const filePath = _path.default.join(outputDir, fileName);

    try {
      await _fsExtra.default.writeFile(filePath, content, {
        flag: 'wx'
      });
    } catch (err) {
      if (err.code === 'EEXIST') {
        output.warn(`\n${_chalk.default.yellow('⚠')} File "${filePath}" already exists, skipping`);
      } else {
        throw err;
      }
    }
  }
};

exports.default = _default;

function isFirstParty(pkg) {
  return pkg.indexOf('@sanity/') === 0;
}